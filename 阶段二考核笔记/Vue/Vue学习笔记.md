# Vue 学习笔记

### **一、Vue？前端框架？**

#### **1、什么是前端框架？**

前端框架是==为了简化和加速 Web 应用开发而创建的、经过优化的工具集==。

可以将其比作一个**标准化的现代厨房**。在没有框架的时代（使用原生JavaScript），开发者需要亲自处理所有底层细节，如同自己砌灶、接水管、布线。而框架则提供了一整套功能完备的设施（如封装好的DOM操作、事件系统），让开发者能专注于**业务逻辑的实现**（做什么菜），而无需过度关心底层是如何工作的（炉灶的点火原理）。

- **核心作用**：抽象底层细节，提供一套结构化的开发范式，从而提升开发效率、代码可维护性和项目稳定性。
- **主流三大框架**：**Vue**、**React**、**Angular**。其中，Vue 以其平缓的学习曲线和出色的开发体验而备受青睐。

#### **2. Vue 的核心特点是什么？**

- **渐进式框架 (Progressive Framework)**
  - 这个特性为 Vue 带来了极高的灵活性。你可以像**搭积木**一样，在项目中按需引入 Vue 的功能。既可以只用其核心库来增强一个既有页面，也可以整合其完整的生态系统（如 `Vue Router`、`Pinia`）来构建一个复杂的单页应用（SPA）。**<u>核心思想是：不强加，不设限，按需取用</u>**。
- **声明式渲染 (Declarative Rendering)**
  - ==这是 Vue 乃至现代前端框架的基石思想==。开发者只需通过代码**声明**“数据与视图的映射关系”，当数据变更时，框架会自动且高效地完成视图的更新。
  - *对比：原生JS的命令式操作，需要开发者手动编写每一步DOM变更的指令，过程繁琐且容易出错。*
- **组件化系统 (Component-based System)**
  - 现代前端工程化的核心。它允许将复杂的UI界面拆解为一个个==独立、可复用、高内聚==的“组件”（`.vue` 文件）。每个组件封装了自己的结构（HTML）、表现（CSS）和行为（JS），实现了完美的**关注点分离**。
- **易用性与生态**
  - 官方文档详尽清晰，对初学者非常友好。
  - 社区生态繁荣，解决方案和第三方库丰富。
  - 基于 `Vite` 的构建工具链提供了近乎瞬时的启动和热更新，开发体验流畅。

### **二、Vue 的使用入门**

#### **1. 项目搭建完整流程**

1. **安装 Node.js (必备前提)**

   - Vue 的开发环境依赖于 Node.js，从其官网下载并安装 **LTS (长期支持)** 版本。

   - 安装完成后，在命令行工具中执行以下命令，验证安装成功：

     ```
     node -v
     npm -v
     ```

2. **创建 Vue 项目**

   - 官方推荐使用 `create-vue` 脚手架，它提供了一个交互式的项目配置向导。

     ```
     npm create vue@latest
     ```

   - 根据向导提示进行选择，对于初学者，建议至少启用 `Vue Router` 和 `Pinia`。

3. **启动项目**

   - 项目创建后，遵循以下标准步骤即可启动开发服务器：

     ```
     # 1. 进入项目目录
     cd your-project-name
     
     # 2. 安装项目依赖
     npm install
     
     # 3. 启动开发服务器
     npm run dev
     ```

   - 启动成功后，在浏览器中访问命令行提示的本地地址（通常是 `http://localhost:5173`），即可看到项目欢迎页面。

#### **2. 核心目录结构详解**

> 一个清晰的目录结构是良好项目的开端。

```
my-vue-app/
├─ public/         # 【公共静态资源目录】：此目录文件不会被构建工具处理，会原样复制到输出目录。
├─ src/            # 【核心源码目录】：绝大部分开发工作在此进行。
│  ├─ assets/      # 【项目内资源目录】：存放会被引用的图片、样式等，会被Vite处理和优化。
│  ├─ components/  # 【通用组件目录】：存放可被多处复用的“基础零件”，如自定义按钮、弹窗等。
│  ├─ views/       # 【视图组件目录】：存放“页面级”组件，通常由路由直接渲染，负责组织通用组件。
│  ├─ router/      # 【路由配置目录】：定义应用的页面路径与视图组件的映射关系。
│  ├─ stores/      # 【状态管理目录】：使用Pinia定义和管理全局共享状态。
│  ├─ App.vue      # 【根组件】：所有视图组件的挂载点和渲染出口。
│  └─ main.js      # 【应用入口文件】：初始化Vue实例、注册插件并挂载根组件。
├─ index.html      # 【主HTML文件】：单页应用的宿主页面，Vue应用最终被挂载到此文件的 <div id="app"></div> 中。
└─ package.json    # 【项目依赖清单】：定义了项目信息、依赖库及脚本命令。
```

#### **3. 核心文件详解**

1. **`main.js` (应用入口)**
   - 其核心职责是**创建和配置Vue应用实例**，整合路由、状态管理等全局插件，并将其与DOM关联起来。
2. **`App.vue` (根组件)**
   - **单文件组件 (SFC)** 的设计是Vue的一大亮点，它将一个组件的模板、脚本和样式封装在单个 `.vue` 文件中，极大地提升了代码的内聚性和可维护性。
   - `<style scoped>` 属性是实现组件样式隔离的关键。它通过为组件的DOM元素添加唯一的自定义属性，并改写CSS选择器，==从而有效避免了全局样式污染的问题==。

### **三、Vue 核心语法**

#### **1. 模板语法**

- `{{ }}` (Mustache语法)：用于文本插值，是数据绑定的基础形式。

#### **2. 常用指令**

| **指令 (简写)**   | **功能描述**                                   | **关键点**                                                   |
| ----------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| `:src="imgUrl"`   | **属性绑定**：动态更新HTML元素的属性。         | 简写形式 `:` 是 `v-bind:` 的别名。                           |
| `@click="fn"`     | **事件监听**：为元素绑定事件处理器。           | 简写形式 `@` 是 `v-on:` 的别名。                             |
| `v-model="msg"`   | **双向数据绑定**：主要用于表单元素，是语法糖。 | 简化了 `:value` 和 `@input` 事件的组合。                     |
| `v-if` / `v-show` | **条件渲染/显示**：控制元素的可见性。          | **`v-if` 是真正的条件性销毁和重建，有更高的切换开销；`v-show` 仅切换CSS的 `display` 属性，有更高的初始渲染开销。** |
| `v-for`           | **列表渲染**：用于遍历数组或对象来生成列表。   | **必须提供唯一的 `:key`**，这是Vue高效更新列表的身份标识。   |



**Vue vs 原生 DOM 操作对照表**：

| **功能/需求**      | **Vue 写法 (声明式)**                            | **原生 JS 写法 (命令式)**                                    |
| ------------------ | ------------------------------------------------ | ------------------------------------------------------------ |
| **绑定文本**       | `<div>{{ message }}</div>`                       | `const div = document.getElementById('myDiv'); div.textContent = message;` |
| **条件显示**       | `<div v-if="isVisble">...</div>`                 | `if (isVisible) { div.style.display = 'block'; } else { div.style.display = 'none'; }` |
| **循环列表**       | `<li v-for="item in items">{{ item.name }}</li>` | `items.forEach(item => { const li = document.createElement('li'); li.textContent = item.name; ul.appendChild(li); });` |
| **表单输入绑定**   | `<input v-model="name">`                         | `input.value = name; input.addEventListener('input', (e) => { name = e.target.value; });` |
| **点击事件**       | `<button @click="doSomething">Click</button>`    | `button.addEventListener('click', doSomething);`             |
| **class 动态切换** | `<div :class="{ active: isActive }"></div>`      | `if (isActive) { div.classList.add('active'); } else { div.classList.remove('active'); }` |

#### **3. 响应式 API**

> 这是Vue实现数据驱动视图的魔法核心。

- **`ref()` 与 `reactive()`**
  - **`ref()`**：一个**通用的响应式容器**，可以包装任何数据类型。在 `<script>` 中访问其值时，必须通过 `.value` 属性。
  - **`reactive()`**：**专用于对象类型**（Object, Array）的响应式代理。访问其属性时无需 `.value`。
  - **实践选择**：虽然两者都能处理对象，但一个常见的最佳实践是：==使用 `ref` 处理所有数据类型，以保持心智模型的一致性（所有响应式数据都通过 `.value` 访问）==。这可以减少在开发过程中对API选择的困惑。

💡

> 学习Vue，最重要的是完成一次从“命令式”到“声明式”的**心智模型转变**。
>
> - **传统命令式思维**：关注“如何做”，即手动编写DOM操作的每一步指令。
> - **Vue声明式思维**：关注“做什么”，即只关心**状态（State）以及它应该如何映射到视图（View）**。
> - 这种转变的价值在于，它将复杂的UI交互逻辑，**降维**成了相对简单的**数据处理逻辑**。开发者得以从繁琐的DOM操作中解放出来，专注于业务本身，从而极大地提升了代码的可读性和可维护性。

### **四、组件化开发**

#### **1. 父子通信**

> 组件间的通信遵循着清晰的规则：**<u>Props down, Events up</u>** (属性向下传递，事件向上传递)。

- **Props (父 -> 子)**：数据通过属性**单向地**从父组件流向子组件。子组件应将`props`视为只读，不应直接修改，以保证数据流的可追溯性。
- **Emit (子 -> 父)**：当子组件需要与父组件通信时（例如，用户在子组件内进行了操作），它会**触发一个自定义事件** (`emit`)，父组件通过监听该事件来做出响应。

#### **2. 思考：组件化背后的架构思维**

> 深入理解组件化，意味着从一个**功能的实现者**，转变为一个**系统的设计者**。

- 这要求开发者在编写代码前进行思考：
  - **职责边界**：这个组件的核心职责是什么？哪些功能应该内聚，哪些应该分离？
  - **接口设计**：组件的 `props` 应该如何设计，才能使其既能满足当前需求，又具备良好的通用性和扩展性？
  - **事件契约**：组件应该向外暴露哪些 `emits`，作为其与外部世界通信的契约？
- 这种自上而下的设计思维，是构建大型、可维护应用的基础。

### **五、路由管理 (vue-router)**

#### **1. history 模式的选择**

- `createWebHistory()` (history模式)：URL美观，不含`#`。但依赖服务器端配置支持，否则在用户刷新页面时可能导致404错误。
- `createWebHashHistory()` (hash模式)：URL中包含`#`，但**兼容性极佳**，无需任何服务器配置即可正常工作。
- **建议**：==在不确定服务器环境或追求最大兼容性时，`hash`模式是最稳妥的选择==。

#### **2. 路由懒加载**

- `component: () => import(...)` 的写法是**一项关键的性能优化技术**。
- 它使得对应页面的代码只在用户首次访问时才会被网络加载，从而显著降低了应用首页的初始加载体积，提升了首屏渲染速度和用户体验。

### **六、状态管理 (Pinia)**

#### **为什么需要它？**

- 当应用复杂度提升，多个无直接关系的组件需要共享或响应同一份数据时（如用户登录状态、主题配置），通过`props`逐层传递会变得极其繁琐和脆弱，这种现象被称为**“属性钻探”（prop drilling）**。
- `Pinia` 提供了一个**集中式的全局状态管理中心 (Store)**。任何组件都可以直接从中读取状态或调用方法来更新状态，彻底解决了跨组件通信的难题。

### **七、组件库使用**

> 使用成熟的UI组件库（如Element Plus, Naive UI），能极大地加速开发进程，如同**从手工作坊升级到工业化生产线**。

它们提供了一套设计统一、功能完备、经过充分测试的UI组件，让开发者可以专注于业务逻辑的实现，而非UI细节的打磨。

### 
